/**
 * @author Administrator
 * jvm一大难点或者一大精髓就是JMM(java内存模型)
 * 由于java内存模型的出现，java也屏蔽了底层内存，我们只用了解虚拟机内存，嘿嘿，说的不太全面
 * 内存模型可以理解为在特定的操作协议下，对特定的内存或告诉缓存进行读写访问的过程的抽象。
 * jvm内存模型大致是 java线程   <---> 工作内存 	<---> save和load操作  <-->主内存
 * 
 * 一般内存间交互操作，有个顺序，大致就是，主内存和工作内存
 * lock unlock read load use assign store write
 * 这些个操作有一定的规则，详细请看jvn虚拟机规范把
 * 
 * 		缓存一致性：每个处理器都有缓存，缓存解决了内存和cpu速度不匹配的问题，但是也给我们抛出了一个新问题，就是缓存一致性问题，也就是说多个处理器的运算任务都
 * 设计同一块主内存区域时，将可能导致各自缓存不一致，如果真的发生这种情况，那如何才能确保缓存一致性尼
 * 				解决，处理器访问缓存时都遵循某些协议，也就是读写的时候根据协议进行
 * 
 * 		第一个关键字volatile，能想到的词，易变，内存可见，禁止指令重排序，并不能当作线程安全的变量来使用
 * 
 * 		说道happen-before：来个总结
 * 			程序次序规则(Program Order Rule):一个线程内，按照程序代码顺序执行
 * 			管程锁定规则(Monitor Lock Rule):一个unlock操作的先行发生于后面对同一个锁的lock操作。同一个锁
 * 			volatile变量规则(Volatile Variable Rule):对一个volatile变量的写操作先行发生于后面对这个变量的读操作
 * 			线程启动规则(Thread Start Rule):Thread对象的start方法先行发生与此线程的每一个动作
 * 			线程终止规则(Thread Termination Rule):线程中的所有操作都先行与对此线程的终止检测。Thread.join方法结束，Thread.isAlive()检测线程终止执行
 * 			线程中断规则(Thread Interruption Rule):对线程的interrupt方法的调用发生于被中断线程的代码检测到中断时间的发生Thread.interrupted()方法检测是否中断发生
 * 			对象终结规则(Finalize Rule):一个对象的初始化完成(构造函数执行结束)先行发生于它finalize()方法的开始
 * 			传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C
 * 
 * 	头疼的东西线程又来了，线程(CPU调度的基本单位)，进程(拥有资源的基本单位)
 * 		线程很重要，操作系统对线程的支持，最终线程还是通过操作系统来分配，我们只是调用系统提供的API 不知道这句话的正确性。嘻嘻嘻自己总结的
 * 					内核线程：直接由操作系统内核支持的线程(KLT)
 * 					用户线程：除了内核线程都是用户线程(一般调用内核线程提供的高级接口，轻量级进程LWP)
 * 					线程这里请忽略这里写的，自己最好还是看看操作系统把，
 * 					主要那个图太烦人，内核线程和轻量级进程1:1，进程和用户线程之间1:N，用户线程和轻量级进程N:M
 * 		然后线程的调度：系统为线程分配处理器的使用权，分为协同线程调度，抢占式线程调度，这。。。
 * 		又涉及到线程的状态转换,新建，就绪，运行，阻塞，结束
 * 
 * 	大头：线程安全，和锁优化
 * 
 * 		线程安全的定义：
 * 				当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个
 * 			对象的行为都可以获得真确的结果，那么这个对象是线程安全的
 * 
 * 		java中的线程安全
 * 			不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施
 * 			记住要是绝对的线程安全！例如Vector这个线程安全类，在某些环境下，就没办法绝对线程安全
 * 
 * 		如何保证：这两个都是可重入锁
 * 			synchronzied:
 * 				synchronzied经过编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令
 * 			这两个执行都需要一个reference类型的参数来致命要锁定和解锁的对象，没有制定，就默认的是当前实例对象或者Class对象
 * 			这里需要记住的就是，是对象锁，获取对象锁，对象锁貌似就在对象头中，哈哈，这个就很麻烦了，什么偏向锁，轻量级锁，重量级锁，自旋锁，后面再细看
 * 			java.util.concurrent包下的锁
 * 				ReentrantLock来是实现同步,这个功能更多，根据有适应性
 * 			CAS:
 * 				非阻塞同步，也就是常说的乐观锁。
 * 			java中的乐观锁基于硬件指令集
 * 			详细说下CAS的原理把，三个操作数，分别是内存位置(理解成变量的内存地址用V标识),旧的预期值(用A表示)，和新值(B标识)
 * 			执行CAS指令的时候，当且仅当V符合旧的预期值A时，处理器用B来更新V，否则不进行操作，并且上述的处理操作是一个原子操作
 * 			详细的就去看jdk中的sun.misc.Unsafe类中的方法把，我们只能使用反射来使用，被jdk限制了
 * 			ThreadLocal：
 * 				这个不能说是线程安全，这个直接来一个线程一份，大家个弄个的Thread中的一个变量，仔细看看把
 * 			Thread对象中有一个ThreadLocalMap对性爱那个，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键的，
 * 			以本地线程变量为K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个
 * 			独一无二的threadLocalHashCode值，这个值就可以在线程K-V值对中找回对应的本地线程变量(!!!!!!!走一边源码！)
 * 				补充：Thread中的ThreadLocalMap中的key是ThreadLocal      value是ThreadLocal对象set的value
 * 			如何在ThreadLocalMap总去寻找ThreadLocal对象，是通过ThreadLocal.threadLocalHashCode来找的，上面那一段
 * 			提出质疑，过后在想，还要思考下ThreadLocalMap.Entry中key的弱引用意义，以及key释放，value不释放的内存溢出
 * 
 * 		锁优化:涉及到对象头了，啊哈哈！
 * 			各种锁技术，
 * 			适应性自旋锁(Adaptive Spinning)：-XX:+UseSpinning开启自旋锁，自旋，明白？
 * 			琐消除(Lock Elimination)：不存在竞争就消除
 * 			锁粗话(Lock Coarsening):如果一系列的连续操作都对同一个对象反复加锁和解锁，
 * 				甚至出现在循环体中，那么虚拟机会扩大锁的范围(粗化)，一些列操作只加一次锁
 * 
 * 			对象头:
 * 				对象头来了，32位或者64位，对象头为了节省空间采用了服用，可以表示很多种状态，并且可以不同场景进行转化
 * 			下面分析一个32位的结构
 * 					25位			4位				2位			1位
 * 				对象哈希码			存储分代年龄		锁标志		固定位0
 * 				
 * 				根据状态位的不同，各个位置的含义也不同					
 * 				对象哈希码，对象分代年龄				01(未锁定状态)
 * 				指向锁记录的指针						00(轻量级锁锁定状态)
 * 				指向重量级锁的指针					10(膨胀，重量级锁状态)
 * 				空，没有任何信息						11(gc标记)
 * 				偏向线程ID，偏向时间戳，对象分代年龄		01(可偏向状态)						
 * 	
 * 			轻量级锁(LightWeight Locking)：轻量级锁并不是用来代替重量级锁的，他的本意是在没有多线程竞争的前提下，减少传统
 * 				的重量级锁使用的操作系统互斥量产生的性能耗损。
 * 				无锁		->		轻量级锁		->		膨胀成重量级锁
 * 				来个详细的解释，
 * 					在代码进入同步块的时候，如果此同步对象没有被锁定(01状态)，虚拟机首先将在当前线程的帧栈中建立一个名为锁记录(Lock Record)
 * 				的空间，用于存储锁对象目前标记头的拷贝(Displaced Mark Word)，然后虚拟机使用CAS来更新MarkWord为指向锁记录LockRecord
 * 				的指针，如果这个操作成功，就说明这个线程拥有了这个锁，就将Mark Word 的所标志改变成 00 表示当前是轻量级锁状态，如果这个更新操作失败了
 * 				虚拟机会检查指向是否指向当前线程的帧栈，如果指向就说明当前线程已经拥有了这个对象的锁，就可以继续执行，否则就说明这个锁对象被其他线程抢占了，
 * 				如果两条线程征用同一个锁，那轻量级锁就失效了，膨胀成重量级锁，锁标志改变成10，Mark Word 中存储的就是指向重量级锁(互斥量)的指针，
 * 				后面等待锁的线程也就进入阻塞状态了
 * 
 * 			偏向锁(Biased Locking):偏向锁就是在无竞争的情况下把整个同步都消除了，这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，
 * 				该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要进行同步，-XX:+UseBiasedLocking,开启偏向锁
 * 				启用偏向锁		->		存在竞争-> 变成 未锁定，或者轻量级锁,然后就是上面的状态
 * 					假设当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设为01，就是偏向模式，同时使用CAS
 * 				操作把获取到的锁的线程的ID记录在对象的MarkWord中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块是，虚拟机都可以
 * 				不再进行任何同步操作(例如，Locking,Unlocking,MarkWord的Update等)
 * 				当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否处于被锁定的状态，撤销偏向锁，恢复到未锁定状态，或轻量级锁
 * 				状态，后续就如同轻量级锁那样去执行
 * 				
 * 			
 * 
 *
 */
package me.czd.jvm.jvm_learn.jmm;