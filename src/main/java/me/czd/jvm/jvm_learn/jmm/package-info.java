/**
 * @author Administrator
 * jvm一大难点或者一大精髓就是JMM(java内存模型)
 * 由于java内存模型的出现，java也屏蔽了底层内存，我们只用了解虚拟机内存，嘿嘿，说的不太全面
 * 内存模型可以理解为在特定的操作协议下，对特定的内存或告诉缓存进行读写访问的过程的抽象。
 * jvm内存模型大致是 java线程   <---> 工作内存 	<---> save和load操作  <-->主内存
 * 
 * 一般内存间交互操作，有个顺序，大致就是，主内存和工作内存
 * lock unlock read load use assign store write
 * 这些个操作有一定的规则，详细请看jvn虚拟机规范把
 * 
 * 		缓存一致性：每个处理器都有缓存，缓存解决了内存和cpu速度不匹配的问题，但是也给我们抛出了一个新问题，就是缓存一致性问题，也就是说多个处理器的运算任务都
 * 设计同一块主内存区域时，将可能导致各自缓存不一致，如果真的发生这种情况，那如何才能确保缓存一致性尼
 * 				解决，处理器访问缓存时都遵循某些协议，也就是读写的时候根据协议进行
 * 
 * 		第一个关键字volatile，能想到的词，易变，内存可见，禁止指令重排序，并不能当作线程安全的变量来使用
 * 
 * 		说道happen-before：来个总结
 * 			程序次序规则(Program Order Rule):一个线程内，按照程序代码顺序执行
 * 			管程锁定规则(Monitor Lock Rule):一个unlock操作的先行发生于后面对同一个锁的lock操作。同一个锁
 * 			volatile变量规则(Volatile Variable Rule):对一个volatile变量的写操作先行发生于后面对这个变量的读操作
 * 			线程启动规则(Thread Start Rule):Thread对象的start方法先行发生与此线程的每一个动作
 * 			线程终止规则(Thread Termination Rule):线程中的所有操作都先行与对此线程的终止检测。Thread.join方法结束，Thread.isAlive()检测线程终止执行
 * 			线程中断规则(Thread Interruption Rule):对线程的interrupt方法的调用发生于被中断线程的代码检测到中断时间的发生Thread.interrupted()方法检测是否中断发生
 * 			对象终结规则(Finalize Rule):一个对象的初始化完成(构造函数执行结束)先行发生于它finalize()方法的开始
 * 			传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C
 * 
 * 	头疼的东西线程又来了，线程(CPU调度的基本单位)，进程(拥有资源的基本单位)
 * 		线程很重要，操作系统对线程的支持，最终线程还是通过操作系统来分配，我们只是调用系统提供的API 不知道这句话的正确性。嘻嘻嘻自己总结的
 * 					内核线程：直接由操作系统内核支持的线程(KLT)
 * 					用户线程：除了内核线程都是用户线程(一般调用内核线程提供的高级接口，轻量级进程LWP)
 * 					线程这里请忽略这里写的，自己最好还是看看操作系统把，
 * 					主要那个图太烦人，内核线程和轻量级进程1:1，进程和用户线程之间1:N，用户线程和轻量级进程N:M
 * 		然后线程的调度：系统为线程分配处理器的使用权，分为协同线程调度，抢占式线程调度，这。。。
 * 		又涉及到线程的状态转换,新建，就绪，运行，阻塞，结束
 * 
 * 
 * 			大头：线程安全，和锁优化
 * 			
 * 
 *
 */
package me.czd.jvm.jvm_learn.jmm;