
/**
 * @author Administrator
 * 执行引擎是Java虚拟机的最核心的组成部分之一！
 * 虚拟机字节码执行引擎
 * 
 * 栈桢是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。
 * 栈桢存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。
 * 每一个方法从调用开始至执行完成的过程，都对应着一个栈桢在虚拟机栈里面从入栈到出栈的过程。
 * 	简单来说就是虚拟机总有若干个线程，每个线程中有若干个栈桢，每个栈桢有很多信息，还是操作的根本，字节码指令直接操作栈桢
 * 	局部变量表，是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量
 * 
 * 从虚拟机的角度了解了 重载和重写
 * 方法调用
 * 		invoke static		调用静态方法
 * 		invoke special		调用实例构造器<init>方法，私有方法，父类方法
 * 		invoke virtual		调用所有的虚方法，还记得大学的C#么就是可以被复写的方法
 * 		invoke interface	调用接口方法，会在运行时确定一个实现此接口的对象
 * 		invoke dynamic		jdk1.7加入，先在运行时动态解析出此调用点限定符所引用的方法，然后在执行该方法
 * 
 * 多态引发的静态类型和实际类型
 * 	记不记得之前看博客的一张图，一个类的所有方法都再一张表中，表中有方法的实际入口
 * 	如果重写了方法，那么子类入口就是重写的方法，如果没有重写子类的入口就是父类中的方法
 * 	这就是虚方法的特殊之处，虽说java不想c#中有virtual关键字
 * 	还有字段，子类的字段在子类中，父类的字段在父类中，静态是父类，就调用的是父类
 * 		编译期已经决定了使用的是那个方法，运行期只用考虑实际类型
 * 		编译器是静态分派，运行期是动态分派
 * 静态分配的体现---------重载
 * 		静态分配需要考虑静态对象是那个，方法参数是那个，属于多分派类型
 * 动态分配的体现---------重写
 * 		动态分配只考虑接受者的实际类型是啥，所以属于单分派类型
 * 
 * jdk1.7中java.lang.invoke中提供了基于jvm的动态指令调用
 * 可以了解下invoke包下的内容
 * 什么是动态类型语言，就是说跨过编译器，仅在运行期才能确定接受者的对象，以及提供方法作为参数传递
 * 为1.8中的lambda提供了条件
 * 
 *
 */
package me.czd.jvm.jvm_learn.invokeengine;